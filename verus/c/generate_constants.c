/*
 * generate_constants.c - Build-time utility to generate Haraka constants.
 *
 * This program re-implements the necessary parts of Haraka constant generation
 * (specifically the `make_rc` logic, including the sponge) and prints the
 * resulting constants to stdout in a format suitable for inclusion as a C array
 * initializer (`haraka_rc_vrsc.inc`).
 *
 * It is compiled and run by build.rs using the host compiler.
 */

#include <stdio.h>
#include <stdint.h>
#include <stddef.h> // For size_t

// --- Bring in minimal required definitions ---
// (Copied/adapted from common.h, haraka_portable.h, haraka_portable.c)

// From common.h
static inline uint32_t rotl32(uint32_t x, int n) { return (x << n) | (x >> (32 - n)); }
static inline uint32_t rotr32(uint32_t x, int n) { return (x >> n) | (x << (32 - n)); }

// From haraka_portable.h / haraka_portable.c (memcpy/memset)
// Use standard library versions here as this runs on the host.
#include <string.h> // For memcpy, memset

// From haraka_portable.c (AES T-tables and aesenc)
#define WPOLY   0x011b
#define F2(x)   ((x<<1) ^ (((x>>7)&1)*WPOLY))
#define F3(x)   (F2(x) ^ (x))
#define B2W(b0,b1,b2,b3) (((uint32_t)(b3)<<24)|((uint32_t)(b2)<<16)| \
                          ((uint32_t)(b1)<<8)|(b0))
#define U0(p)   B2W(F2(p),    p ,    p , F3(p))
#define U1(p)   B2W(F3(p), F2(p),    p ,    p )
#define U2(p)   B2W(   p , F3(p), F2(p),    p )
#define U3(p)   B2W(   p ,    p , F3(p), F2(p))

#define SBOX(w) { \
    w(0x63),w(0x7c),w(0x77),w(0x7b),w(0xf2),w(0x6b),w(0x6f),w(0xc5), \
    w(0x30),w(0x01),w(0x67),w(0x2b),w(0xfe),w(0xd7),w(0xab),w(0x76), \
    w(0xca),w(0x82),w(0xc9),w(0x7d),w(0xfa),w(0x59),w(0x47),w(0xf0), \
    w(0xad),w(0xd4),w(0xa2),w(0xaf),w(0x9c),w(0xa4),w(0x72),w(0xc0), \
    w(0xb7),w(0xfd),w(0x93),w(0x26),w(0x36),w(0x3f),w(0xf7),w(0xcc), \
    w(0x34),w(0xa5),w(0xe5),w(0xf1),w(0x71),w(0xd8),w(0x31),w(0x15), \
    w(0x04),w(0xc7),w(0x23),w(0xc3),w(0x18),w(0x96),w(0x05),w(0x9a), \
    w(0x07),w(0x12),w(0x80),w(0xe2),w(0xeb),w(0x27),w(0xb2),w(0x75), \
    w(0x09),w(0x83),w(0x2c),w(0x1a),w(0x1b),w(0x6e),w(0x5a),w(0xa0), \
    w(0x52),w(0x3b),w(0xd6),w(0xb3),w(0x29),w(0xe3),w(0x2f),w(0x84), \
    w(0x53),w(0xd1),w(0x00),w(0xed),w(0x20),w(0xfc),w(0xb1),w(0x5b), \
    w(0x6a),w(0xcb),w(0xbe),w(0x39),w(0x4a),w(0x4c),w(0x58),w(0xcf), \
    w(0xd0),w(0xef),w(0xaa),w(0xfb),w(0x43),w(0x4d),w(0x33),w(0x85), \
    w(0x45),w(0xf9),w(0x02),w(0x7f),w(0x50),w(0x3c),w(0x9f),w(0xa8), \
    w(0x51),w(0xa3),w(0x40),w(0x8f),w(0x92),w(0x9d),w(0x38),w(0xf5), \
    w(0xbc),w(0xb6),w(0xda),w(0x21),w(0x10),w(0xff),w(0xf3),w(0xd2), \
    w(0xcd),w(0x0c),w(0x13),w(0xec),w(0x5f),w(0x97),w(0x44),w(0x17), \
    w(0xc4),w(0xa7),w(0x7e),w(0x3d),w(0x64),w(0x5d),w(0x19),w(0x73), \
    w(0x60),w(0x81),w(0x4f),w(0xdc),w(0x22),w(0x2a),w(0x90),w(0x88), \
    w(0x46),w(0xee),w(0xb8),w(0x14),w(0xde),w(0x5e),w(0x0b),w(0xdb), \
    w(0xe0),w(0x32),w(0x3a),w(0x0a),w(0x49),w(0x06),w(0x24),w(0x5c), \
    w(0xc2),w(0xd3),w(0xac),w(0x62),w(0x91),w(0x95),w(0xe4),w(0x79), \
    w(0xe7),w(0xc8),w(0x37),w(0x6d),w(0x8d),w(0xd5),w(0x4e),w(0xa9), \
    w(0x6c),w(0x56),w(0xf4),w(0xea),w(0x65),w(0x7a),w(0xae),w(0x08), \
    w(0xba),w(0x78),w(0x25),w(0x2e),w(0x1c),w(0xa6),w(0xb4),w(0xc6), \
    w(0xe8),w(0xdd),w(0x74),w(0x1f),w(0x4b),w(0xbd),w(0x8b),w(0x8a), \
    w(0x70),w(0x3e),w(0xb5),w(0x66),w(0x48),w(0x03),w(0xf6),w(0x0e), \
    w(0x61),w(0x35),w(0x57),w(0xb9),w(0x86),w(0xc1),w(0x1d),w(0x9e), \
    w(0xe1),w(0xf8),w(0x98),w(0x11),w(0x69),w(0xd9),w(0x8e),w(0x94), \
    w(0x9b),w(0x1e),w(0x87),w(0xe9),w(0xce),w(0x55),w(0x28),w(0xdf), \
    w(0x8c),w(0xa1),w(0x89),w(0x0d),w(0xbf),w(0xe6),w(0x42),w(0x68), \
    w(0x41),w(0x99),w(0x2d),w(0x0f),w(0xb0),w(0x54),w(0xbb),w(0x16)  \
}

static const uint32_t T[4][256] = { SBOX(U0), SBOX(U1), SBOX(U2), SBOX(U3) };

static void aesenc(uint8_t *s, const uint8_t *rk)
{
    const uint32_t *t = T[0];
    uint32_t x0 = ((uint32_t *)s)[0], x1 = ((uint32_t *)s)[1];
    uint32_t x2 = ((uint32_t *)s)[2], x3 = ((uint32_t *)s)[3];
    uint32_t y0 = t[x0 & 0xff]; x0 >>= 8;
    uint32_t y1 = t[x1 & 0xff]; x1 >>= 8;
    uint32_t y2 = t[x2 & 0xff]; x2 >>= 8;
    uint32_t y3 = t[x3 & 0xff]; x3 >>= 8; t += 256;
    y0 ^= t[x1 & 0xff]; x1 >>= 8;
    y1 ^= t[x2 & 0xff]; x2 >>= 8;
    y2 ^= t[x3 & 0xff]; x3 >>= 8;
    y3 ^= t[x0 & 0xff]; x0 >>= 8; t += 256;
    y0 ^= t[x2 & 0xff]; x2 >>= 8;
    y1 ^= t[x3 & 0xff]; x3 >>= 8;
    y2 ^= t[x0 & 0xff]; x0 >>= 8;
    y3 ^= t[x1 & 0xff]; x1 >>= 8; t += 256;
    y0 ^= t[x3]; y1 ^= t[x0]; y2 ^= t[x1]; y3 ^= t[x2];
    ((uint32_t *)s)[0] = y0 ^ ((uint32_t *)rk)[0];
    ((uint32_t *)s)[1] = y1 ^ ((uint32_t *)rk)[1];
    ((uint32_t *)s)[2] = y2 ^ ((uint32_t *)rk)[2];
    ((uint32_t *)s)[3] = y3 ^ ((uint32_t *)rk)[3];
}

// From haraka_portable.c (unpack helpers)
static void unpacklo32(uint8_t *t, uint8_t *a, uint8_t *b)
{
    uint8_t tmp[16];
    memcpy(tmp   , a   , 4);  memcpy(tmp+4 , b   , 4);
    memcpy(tmp+8 , a+4 , 4);  memcpy(tmp+12, b+4 , 4);
    memcpy(t, tmp, 16);
}
static void unpackhi32(uint8_t *t, uint8_t *a, uint8_t *b)
{
    uint8_t tmp[16];
    memcpy(tmp   , a+8 , 4);  memcpy(tmp+4 , b+8 , 4);
    memcpy(tmp+8 , a+12, 4);  memcpy(tmp+12, b+12,4);
    memcpy(t, tmp, 16);
}

// From haraka_constants.c (default constants)
const unsigned char default_haraka_rc[40 * 16] = {
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
  0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
  0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
  0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

// From haraka_portable.c (Sponge logic)
#define RATE 32

// Forward declare the permutation
static void haraka512_perm_internal(uint8_t *o, const uint8_t *i, const uint8_t rc[40][16]);

// Simplified make_rc just for the sponge's internal permutation needs
static void make_sponge_rc(uint8_t dst[40][16]) {
    // For the sponge permutation, we just use the default constants directly.
    // The "VRSC" tweak happens *outside* the sponge, when generating the main constants.
    memcpy(dst, default_haraka_rc, 40 * 16);
}

static void sponge_absorb(uint8_t *s, const uint8_t *m,
                          uint64_t mlen, uint8_t pad)
{
    uint8_t sponge_rc[40][16];
    make_sponge_rc(sponge_rc); // Use default constants for sponge permutation

    while (mlen >= RATE){
        for (unsigned i=0;i<RATE;++i) s[i] ^= m[i];
        haraka512_perm_internal(s, s, sponge_rc);
        m   += RATE;
        mlen-= RATE;
    }
    uint8_t tmp[RATE];
    memset(tmp,0,sizeof tmp);
    memcpy(tmp,m,mlen);
    tmp[mlen] = pad;
    tmp[RATE-1] |= 0x80;
    for (unsigned i=0;i<RATE;++i) s[i] ^= tmp[i];
}

static void sponge_squeeze(uint8_t *out, uint64_t blocks, uint8_t *s)
{
    uint8_t sponge_rc[40][16];
    make_sponge_rc(sponge_rc); // Use default constants

    while (blocks--){
        haraka512_perm_internal(s, s, sponge_rc);
        memcpy(out,s,RATE);
        out += RATE;
    }
}

static void haraka_S(uint8_t *out, uint64_t outlen, const uint8_t *in, uint64_t inlen)
{
    uint8_t st[64]={0}, tmp[32];
    sponge_absorb(st,in,inlen,0x1F);
    sponge_squeeze(out,outlen/32,st);
    out += (outlen/32)*32;
    if (outlen & 31){
        sponge_squeeze(tmp,1,st);
        memcpy(out,tmp,outlen&31);
    }
}

// From haraka_portable.c (haraka512_perm_internal)
static void haraka512_perm_internal(uint8_t *out, const uint8_t *in, const uint8_t rc[40][16])
{
    uint8_t s[64]; // Use stack buffer directly
    uint8_t t[16];

    memcpy(s   ,in    ,16);  memcpy(s+16,in+16,16);
    memcpy(s+32,in+32 ,16);  memcpy(s+48,in+48,16);

    for (unsigned r=0;r<5;++r){
        for (unsigned j=0;j<2;++j){
            aesenc(s     , rc[4*r*2+4*j  ]);
            aesenc(s+16  , rc[4*r*2+4*j+1]);
            aesenc(s+32  , rc[4*r*2+4*j+2]);
            aesenc(s+48  , rc[4*r*2+4*j+3]);
        }
        unpacklo32(t ,s   ,s+16);  unpackhi32(s   ,s   ,s+16);
        unpacklo32(s+16,s+32,s+48); unpackhi32(s+32,s+32,s+48);
        unpacklo32(s+48,s   ,s+32); unpackhi32(s   ,s   ,s+32);
        unpackhi32(s+32,s+16,t  );  unpacklo32(s+16,s+16,t  );
    }
    memcpy(out,s,64);
}

// --- Main generation logic (adapted from make_rc) ---
static void generate_vrsc_constants(uint8_t dst[40][16])
{
    uint8_t buf[40*16]; // Temporary buffer for sponge output

    // Initialize dst with the default constants
    memcpy(dst, default_haraka_rc, 40*16);

    // Apply primary key (pk) tweak ("VRSC") using the sponge
    haraka_S(buf, 40*16, (const uint8_t*)"VRSC", 4);

    // Copy the tweaked constants from `buf` into the final destination `dst`.
    memcpy(dst, buf, 40*16);
}


int main() {
    uint8_t final_rc[40][16];
    generate_vrsc_constants(final_rc);

    // Print the constants in the desired C array initializer format
    printf("{\n");
    for (int i = 0; i < 40; ++i) {
        printf("  { ");
        for (int j = 0; j < 16; ++j) {
            printf("0x%02x", final_rc[i][j]);
            if (j < 15) {
                printf(",");
            }
            // Add space for alignment, except after the last element
            if (j < 15) {
                 printf(" ");
            }
        }
        printf(" }");
        if (i < 39) {
            printf(",");
        }
        printf("\n");
    }
    printf("};\n");

    return 0;
}

